#!/usr/bin/env node

var pq = require('./priority_queue')
  , assert  = require('assert')
  , vows    = require('vows')
  , numbers = []
  , PriorityQueue = pq.PriorityQueue
  ;

var suite = vows.describe('priority queue').addBatch(
{ 'A new priority queue': 
  { topic: PriorityQueue
  , 'is a PriorityQueue instance': isPriorityQueue
  , 'is empty': function(q) { assert.strictEqual(q.length, 0) }
  }
, 'A filled priority queue': queueTest(42, 5, 23)
, 'An inverted priority queue': queueTest(42, 5, 23, Math.PI, pq.min_first)
, 'A longer priority queue': queueTest.apply(null, numbers)
, 'Comparing a proper queue with a naive one':
  { topic: compare_queues
  , 'both agree on the element order': function(r) {
      assert.deepEqual(r.heap.result, r.naive.result);
    }
  , 'the heap version is more than ten times faster': function(r) {
      //console.log('heap time:', r.heap.time, 'naive time:', r.naive.time);
      assert.isTrue(10 * r.heap.time < r.naive.time);
    }
  , 'all input values appear in the output': function(r) {
      r.input.forEach(function(v, i) {
        assert.notEqual(r.naive.result.indexOf(v), -1);
        assert.notEqual(r.heap.result.indexOf(v), -1);
      });
    }
  , 'all output values appear in the input': function(r) {
      r.heap.result.forEach(function(v, i) {
        assert.notEqual(r.input.indexOf(v), -1);
      });
    }
  , 'element count is the same on the input and output side': function(r) {
      assert.strictEqual(r.heap.result.length, r.input.length);
      assert.strictEqual(r.naive.result.length, r.input.length);
    }
  }
});
suite.reporter = require('vows/lib/vows/reporters/spec');
suite.run();

function isPriorityQueue(q) {
  assert.instanceOf(q, PriorityQueue);
}

function pqueueWithItems() {
  var items = arguments;
  return function() {
    var q = new PriorityQueue();
    q.push.apply(q, items);
    return q;
  }
}

function queueTest() {
  var items = Array.prototype.slice.call(arguments)
    , cmp = (typeof items[items.length - 1] === 'function') ? items.pop() : undefined
    , ctx = {}
    ;
  ctx.topic = function() {
    var q = new PriorityQueue(cmp)
      , nq = new NaiveQueue(cmp);

    q.push.apply(q, items);
    nq.push.apply(q, items);
    return {q: q, nq: nq};
  }
  ctx['returns the items in order'] = function(qs) {
    while (qs.q.length) {
      assert.strictEqual(qs.q.length, qs.nq.length);
      assert.strictEqual(qs.q.shift(), qs.nq.shift());
    }
  }
  return ctx;
}

numbers = random_numbers(100);

function queue_time(queue_type, bc, puc, poc, els, popped) {
  var start = Date.now();
  var q = new queue_type();
  for (var i = 0; i < bc; ++i) {
    for (var j = 0; j < puc; ++j) {
      q.push(els[i * bc + j]);
    }
    for (var j = 0; j < poc; ++j) { popped.push(q.shift()); }
  }
  while (q.length > 0) { popped.push(q.shift()); }
  return Date.now() - start;
}

function random_numbers(n) {
  var r = [], i;
  for (i = 0; i < n; ++i) { r.push(Math.random() * 2000 - 1000) }
  return r;
}

var NaiveQueue = function NaiveQueue(cmp, a) {
  cmp =  cmp || pq.min_first;
  a   = (a   || []).sort(cmp);
  this.push = function push() { a.push.apply(a, arguments); a.sort(cmp); }
  this.shift  = function shift()  { return a.shift(); }
  this.__defineGetter__('length', function length() { return a.length });
}

function compare_queues() {
  var blocks = 20, pushs = 20, pops = 5
    , elements = random_numbers(blocks * pushs)
    , naive_elements = []
    , naive_time = queue_time(NaiveQueue, blocks, pushs, pops, elements, naive_elements)
    , heap_elements = []
    , heap_time = queue_time(PriorityQueue, blocks, pushs, pops, elements, heap_elements)
    ;
  return { naive: { time: naive_time, result: naive_elements}
         , heap: { time: heap_time, result: heap_elements}
         , input: elements
         };
}

// vim: set filetype=javascript :
